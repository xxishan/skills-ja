# MCP サーバー開発のベストプラクティスとガイドライン

## 概要

このドキュメントは、Model Context Protocol（MCP）サーバーを構築するための重要なベストプラクティスとガイドラインをまとめたものです。命名規則、ツール設計、応答フォーマット、ページネーション、エラーハンドリング、セキュリティ、コンプライアンス要件をカバーしています。

---

## クイックリファレンス

### サーバー命名

- **Python**: `{service}_mcp`（例: `slack_mcp`）
- **Node/TypeScript**: `{service}-mcp-server`（例: `slack-mcp-server`）

### ツール命名

- サービスプレフィックス付きの snake_case を使用
- フォーマット: `{service}_{action}_{resource}`
- 例: `slack_send_message`、`github_create_issue`

### 応答フォーマット

- JSON と Markdown の両方のフォーマットをサポート
- JSON はプログラム的処理用
- Markdown は人間の可読性用

### ページネーション

- 常に`limit`パラメータを尊重
- `has_more`、`next_offset`、`total_count`を返す
- デフォルトは 20〜50 項目

### 文字制限

- CHARACTER_LIMIT 定数を設定（通常 25,000）
- 明確なメッセージで適切に切り捨て
- フィルタリングに関するガイダンスを提供

---

## 目次

1. サーバー命名規則
2. ツールの命名と設計
3. 応答フォーマットガイドライン
4. ページネーションのベストプラクティス
5. 文字制限と切り捨て
6. ツール開発のベストプラクティス
7. トランスポートのベストプラクティス
8. テスト要件
9. OAuth とセキュリティのベストプラクティス
10. リソース管理のベストプラクティス
11. プロンプト管理のベストプラクティス
12. エラーハンドリング標準
13. ドキュメント要件
14. コンプライアンスと監視

---

## 1. サーバー命名規則

MCP サーバーの標準化された命名パターンに従います:

**Python**: フォーマット`{service}_mcp`を使用（アンダースコア付き小文字）

- 例: `slack_mcp`、`github_mcp`、`jira_mcp`、`stripe_mcp`

**Node/TypeScript**: フォーマット`{service}-mcp-server`を使用（ハイフン付き小文字）

- 例: `slack-mcp-server`、`github-mcp-server`、`jira-mcp-server`

名前は以下であるべきです:

- 一般的（特定の機能に紐付かない）
- 統合されるサービス/API を説明的に表す
- タスクの説明から推測しやすい
- バージョン番号や日付なし

---

## 2. ツールの命名と設計

### ツール命名のベストプラクティス

1. **snake_case を使用**: `search_users`、`create_project`、`get_channel_info`
2. **サービスプレフィックスを含める**: MCP サーバーが他の MCP サーバーと一緒に使用される可能性を想定
   - `send_message`ではなく`slack_send_message`を使用
   - `create_issue`ではなく`github_create_issue`を使用
   - `list_tasks`ではなく`asana_list_tasks`を使用
3. **アクション指向**: 動詞で始める（get、list、search、create など）
4. **具体的に**: 他のサーバーと競合する可能性のある一般的な名前を避ける
5. **一貫性を維持**: サーバー内で一貫した命名パターンを使用

### ツール設計ガイドライン

- ツールの説明は機能を狭く明確に記述する必要がある
- 説明は実際の機能と正確に一致する必要がある
- 他の MCP サーバーとの混乱を引き起こさないべき
- ツールアノテーションを提供すべき（readOnlyHint、destructiveHint、idempotentHint、openWorldHint）
- ツール操作を焦点を絞ったアトミックに保つ

---

## 3. 応答フォーマットガイドライン

データを返すすべてのツールは、柔軟性のために複数のフォーマットをサポートする必要があります:

### JSON フォーマット（`response_format="json"`）

- 機械可読な構造化データ
- 利用可能なすべてのフィールドとメタデータを含める
- 一貫したフィールド名と型
- プログラム的処理に適している
- LLM がデータをさらに処理する必要がある場合に使用

### Markdown フォーマット（`response_format="markdown"`、通常はデフォルト）

- 人間が読める形式のテキスト
- 明確さのためにヘッダー、リスト、フォーマットを使用
- タイムスタンプを人間が読める形式に変換（例: エポック時間ではなく「2024-01-15 10:30:00 UTC」）
- ID を括弧内に表示名と共に表示（例: "@john.doe (U123456)"）
- 冗長なメタデータを省略（例: すべてのサイズではなく 1 つのプロフィール画像 URL のみを表示）
- 関連情報を論理的にグループ化
- ユーザーに情報を提示する際に使用

---

## 4. ページネーションのベストプラクティス

リソースをリストするツールの場合:

- **常に`limit`パラメータを尊重**: 制限が指定されている場合、すべての結果をロードしない
- **ページネーションを実装**: `offset`またはカーソルベースのページネーションを使用
- **ページネーションメタデータを返す**: `has_more`、`next_offset`/`next_cursor`、`total_count`を含める
- **すべての結果をメモリにロードしない**: 特に大きなデータセットで重要
- **合理的な制限をデフォルトにする**: 20〜50 項目が一般的
- **応答に明確なページネーション情報を含める**: LLM がより多くのデータを要求しやすくする

ページネーション応答構造の例:

```json
{
  "total": 150,
  "count": 20,
  "offset": 0,
  "items": [...],
  "has_more": true,
  "next_offset": 20
}
```

---

## 5. 文字制限と切り捨て

過剰なデータで応答を圧倒しないようにするため:

- **CHARACTER_LIMIT 定数を定義**: モジュールレベルで通常 25,000 文字
- **返す前に応答サイズをチェック**: 最終的な応答長を測定
- **明確な指標で適切に切り捨て**: データが切り捨てられたことを LLM に知らせる
- **フィルタリングに関するガイダンスを提供**: パラメータを使用して結果を減らす方法を提案
- **切り捨てメタデータを含める**: 何が切り捨てられたか、より多くを取得する方法を示す

切り捨て処理の例:

```python
CHARACTER_LIMIT = 25000

if len(result) > CHARACTER_LIMIT:
    truncated_data = data[:max(1, len(data) // 2)]
    response["truncated"] = True
    response["truncation_message"] = (
        f"応答を{len(data)}項目から{len(truncated_data)}項目に切り捨てました。"
        f"より多くの結果を見るには'offset'パラメータを使用するか、フィルターを追加してください。"
    )
```

---

## 6. トランスポートオプション

MCP サーバーは、異なる展開シナリオに対応する複数のトランスポートメカニズムをサポートしています:

### Stdio トランスポート

**最適な用途**: コマンドラインツール、ローカル統合、サブプロセス実行

**特徴**:

- 標準入出力ストリーム通信
- シンプルなセットアップ、ネットワーク設定不要
- クライアントのサブプロセスとして実行
- デスクトップアプリケーションと CLI ツールに最適

**使用する場合**:

- ローカル開発環境用のツールを構築
- デスクトップアプリケーションとの統合（例: Claude Desktop）
- コマンドラインユーティリティの作成
- シングルユーザー、シングルセッションのシナリオ

### HTTP トランスポート

**最適な用途**: Web サービス、リモートアクセス、マルチクライアントシナリオ

**特徴**:

- HTTP 上のリクエスト-レスポンスパターン
- 複数の同時クライアントをサポート
- Web サービスとして展開可能
- ネットワーク設定とセキュリティの考慮が必要

**使用する場合**:

- 複数のクライアントに同時にサービスを提供
- クラウドサービスとして展開
- Web アプリケーションとの統合
- ロードバランシングまたはスケーリングが必要

### Server-Sent Events（SSE）トランスポート

**最適な用途**: リアルタイム更新、プッシュ通知、ストリーミングデータ

**特徴**:

- HTTP 上の一方向サーバーからクライアントへのストリーミング
- ポーリングなしでリアルタイム更新を可能にする
- 継続的なデータフローのための長期接続
- 標準 HTTP インフラストラクチャ上に構築

**使用する場合**:

- クライアントがリアルタイムデータ更新を必要とする
- プッシュ通知の実装
- ログや監視データのストリーミング
- 長期操作の段階的な結果配信

### トランスポート選択基準

| 基準             | Stdio    | HTTP                  | SSE              |
| ---------------- | -------- | --------------------- | ---------------- |
| **展開**         | ローカル | リモート              | リモート         |
| **クライアント** | 単一     | 複数                  | 複数             |
| **通信**         | 双方向   | リクエスト-レスポンス | サーバープッシュ |
| **複雑さ**       | 低       | 中                    | 中〜高           |
| **リアルタイム** | いいえ   | いいえ                | はい             |

---

## 7. ツール開発のベストプラクティス

### 一般的なガイドライン

1. ツール名は説明的でアクション指向であるべき
2. 詳細な JSON スキーマでパラメータ検証を使用
3. ツールの説明に例を含める
4. 適切なエラーハンドリングと検証を実装
5. 長期操作に進行状況レポートを使用
6. ツール操作を焦点を絞ったアトミックに保つ
7. 期待される戻り値構造をドキュメント化
8. 適切なタイムアウトを実装
9. リソース集約的な操作にレート制限を検討
10. デバッグと監視のためにツール使用をログ記録

### ツールのセキュリティ考慮事項

#### 入力検証

- スキーマに対してすべてのパラメータを検証
- ファイルパスとシステムコマンドをサニタイズ
- URL と外部 ID を検証
- パラメータのサイズと範囲をチェック
- コマンドインジェクションを防止

#### アクセス制御

- 必要に応じて認証を実装
- 適切な認可チェックを使用
- ツール使用を監査
- リクエストをレート制限
- 悪用を監視

#### エラーハンドリング

- 内部エラーをクライアントに公開しない
- セキュリティ関連のエラーをログ記録
- タイムアウトを適切に処理
- エラー後にリソースをクリーンアップ
- 戻り値を検証

### ツールアノテーション

- readOnlyHint と destructiveHint アノテーションを提供
- アノテーションはヒントであり、セキュリティ保証ではないことを覚えておく
- クライアントはアノテーションのみに基づいてセキュリティクリティカルな決定を行うべきではない

---

## 8. トランスポートのベストプラクティス

### 一般的なトランスポートガイドライン

1. 接続ライフサイクルを適切に処理
2. 適切なエラーハンドリングを実装
3. 適切なタイムアウト値を使用
4. 接続状態管理を実装
5. 切断時にリソースをクリーンアップ

### トランスポートのセキュリティベストプラクティス

- DNS リバインディング攻撃のセキュリティ考慮事項に従う
- 適切な認証メカニズムを実装
- メッセージフォーマットを検証
- 不正なメッセージを適切に処理

### Stdio トランスポート固有

- ローカル MCP サーバーは stdout にログ記録すべきではない（プロトコルに干渉）
- ログメッセージに stderr を使用
- 標準 I/O ストリームを適切に処理

---

## 9. テスト要件

包括的なテスト戦略は以下をカバーする必要があります:

### 機能テスト

- 有効/無効な入力での正しい実行を検証

### 統合テスト

- 外部システムとの相互作用をテスト

### セキュリティテスト

- 認証、入力サニタイゼーション、レート制限を検証

### パフォーマンステスト

- 負荷下の動作、タイムアウトをチェック

### エラーハンドリング

- 適切なエラー報告とクリーンアップを確認

---

## 10. OAuth とセキュリティのベストプラクティス

### 認証と認可

外部サービスに接続する MCP サーバーは適切な認証を実装する必要があります:

**OAuth 2.1 実装:**

- 認定機関からの証明書を持つ安全な OAuth 2.1 を使用
- リクエストを処理する前にアクセストークンを検証
- サーバー専用のトークンのみを受け入れる
- 適切なオーディエンスクレームのないトークンを拒否
- MCP クライアントから受信したトークンをパススルーしない

**API キー管理:**

- API キーは環境変数に保存し、コードには絶対に保存しない
- サーバー起動時にキーを検証
- 認証が失敗した場合、明確なエラーメッセージを提供
- 機密資格情報には安全な送信を使用

### 入力検証とセキュリティ

**常に入力を検証:**

- ディレクトリトラバーサルを防ぐためにファイルパスをサニタイズ
- URL と外部 ID を検証
- パラメータのサイズと範囲をチェック
- システムコールでのコマンドインジェクションを防止
- すべての入力にスキーマ検証（Pydantic/Zod）を使用

**エラーハンドリングのセキュリティ:**

- 内部エラーをクライアントに公開しない
- セキュリティ関連のエラーをサーバー側でログ記録
- 役立つが明示的ではないエラーメッセージを提供
- エラー後にリソースをクリーンアップ

### プライバシーとデータ保護

**データ収集の原則:**

- 機能に厳密に必要なデータのみを収集
- 無関係な会話データを収集しない
- ツールの目的に明示的に必要でない限り PII を収集しない
- アクセスされるデータについて明確な情報を提供

**データ送信:**

- 開示なしに組織外のサーバーにデータを送信しない
- すべてのネットワーク通信に安全な送信（HTTPS）を使用
- 外部サービスの証明書を検証

---

## 11. リソース管理のベストプラクティス

1. 必要なリソースのみを提案
2. ルートに明確で説明的な名前を使用
3. リソース境界を適切に処理
4. リソースに対するクライアントの制御を尊重
5. 自動データ公開にモデル制御プリミティブ（ツール）を使用

---

## 12. プロンプト管理のベストプラクティス

- クライアントは提案されたプロンプトをユーザーに表示すべき
- ユーザーはプロンプトを変更または拒否できるべき
- クライアントは補完をユーザーに表示すべき
- ユーザーは補完を変更または拒否できるべき
- サンプリング使用時にコストを考慮

---

## 13. エラーハンドリング標準

- 標準 JSON-RPC エラーコードを使用
- 結果オブジェクト内でツールエラーを報告（プロトコルレベルではない）
- 役立つ、具体的なエラーメッセージを提供
- 内部実装の詳細を公開しない
- エラー時に適切にリソースをクリーンアップ

---

## 14. ドキュメント要件

- すべてのツールと機能の明確なドキュメントを提供
- 主要な機能ごとに少なくとも 3 つの動作例を含める
- セキュリティの考慮事項をドキュメント化
- 必要な権限とアクセスレベルを指定
- レート制限とパフォーマンス特性をドキュメント化

---

## 15. コンプライアンスと監視

- デバッグと監視のためのログを実装
- ツール使用パターンを追跡
- 潜在的な悪用を監視
- セキュリティ関連操作の監査証跡を維持
- 継続的なコンプライアンスレビューに備える

---

## まとめ

これらのベストプラクティスは、エコシステム内でうまく機能する安全で効率的、かつコンプライアンスに準拠した MCP サーバーを構築するための包括的なガイドラインを表しています。開発者は、MCP ディレクトリに含めるための基準を満たし、ユーザーに安全で信頼性の高い体験を提供するために、これらのガイドラインに従う必要があります。

---

# ツール

> LLM がサーバーを通じてアクションを実行できるようにする

ツールは、サーバーが実行可能な機能をクライアントに公開できるようにする Model Context Protocol（MCP）の強力なプリミティブです。ツールを通じて、LLM は外部システムと対話し、計算を実行し、現実世界でアクションを実行できます。

<Note>
  ツールは**モデル制御**されるように設計されています。つまり、ツールはサーバーからクライアントに公開され、AIモデルが（承認を得るために人間をループに入れて）自動的に呼び出すことができることを意図しています。
</Note>

## 概要

MCP のツールにより、サーバーはクライアントが呼び出し、LLM がアクションを実行するために使用できる実行可能関数を公開できます。ツールの主な側面には以下が含まれます:

- **発見**: クライアントは`tools/list`リクエストを送信して利用可能なツールのリストを取得できる
- **呼び出し**: ツールは`tools/call`リクエストを使用して呼び出され、サーバーは要求された操作を実行して結果を返す
- **柔軟性**: ツールは単純な計算から複雑な API 相互作用まで幅広い

[resources](/docs/concepts/resources)と同様に、ツールは一意の名前で識別され、使用法を案内するための説明を含めることができます。ただし、リソースとは異なり、ツールは状態を変更したり外部システムと対話したりできる動的な操作を表します。

## ツール定義構造

各ツールは以下の構造で定義されます:

```typescript
{
  name: string;          // ツールの一意の識別子
  description?: string;  // 人間が読める説明
  inputSchema: {         // ツールのパラメータのJSONスキーマ
    type: "object",
    properties: { ... }  // ツール固有のパラメータ
  },
  annotations?: {        // ツールの動作に関するオプションのヒント
    title?: string;      // ツールの人間が読めるタイトル
    readOnlyHint?: boolean;    // trueの場合、ツールは環境を変更しない
    destructiveHint?: boolean; // trueの場合、ツールは破壊的な更新を実行する可能性がある
    idempotentHint?: boolean;  // trueの場合、同じ引数での繰り返し呼び出しは追加効果がない
    openWorldHint?: boolean;   // trueの場合、ツールは外部エンティティと対話する
  }
}
```

## ツールの実装

MCP サーバーで基本的なツールを実装する例は以下の通りです:

<Tabs>
  <Tab title="TypeScript">
    ```typescript
    const server = new Server({
      name: "example-server",
      version: "1.0.0"
    }, {
      capabilities: {
        tools: {}
      }
    });

    // 利用可能なツールを定義
    server.setRequestHandler(ListToolsRequestSchema, async () => {
      return {
        tools: [{
          name: "calculate_sum",
          description: "2つの数値を加算する",
          inputSchema: {
            type: "object",
            properties: {
              a: { type: "number" },
              b: { type: "number" }
            },
            required: ["a", "b"]
          }
        }]
      };
    });

    // ツール実行を処理
    server.setRequestHandler(CallToolRequestSchema, async (request) => {
      if (request.params.name === "calculate_sum") {
        const { a, b } = request.params.arguments;
        return {
          content: [
            {
              type: "text",
              text: String(a + b)
            }
          ]
        };
      }
      throw new Error("ツールが見つかりません");
    });
    ```

  </Tab>

  <Tab title="Python">
    ```python
    app = Server("example-server")

    @app.list_tools()
    async def list_tools() -> list[types.Tool]:
        return [
            types.Tool(
                name="calculate_sum",
                description="2つの数値を加算する",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "a": {"type": "number"},
                        "b": {"type": "number"}
                    },
                    "required": ["a", "b"]
                }
            )
        ]

    @app.call_tool()
    async def call_tool(
        name: str,
        arguments: dict
    ) -> list[types.TextContent | types.ImageContent | types.EmbeddedResource]:
        if name == "calculate_sum":
            a = arguments["a"]
            b = arguments["b"]
            result = a + b
            return [types.TextContent(type="text", text=str(result))]
        raise ValueError(f"ツールが見つかりません: {name}")
    ```

  </Tab>
</Tabs>

## ツールパターンの例

サーバーが提供できるツールのタイプの例をいくつか示します:

### システム操作

ローカルシステムと対話するツール:

```typescript
{
  name: "execute_command",
  description: "シェルコマンドを実行する",
  inputSchema: {
    type: "object",
    properties: {
      command: { type: "string" },
      args: { type: "array", items: { type: "string" } }
    }
  }
}
```

### API 統合

外部 API をラップするツール:

```typescript
{
  name: "github_create_issue",
  description: "GitHub issueを作成する",
  inputSchema: {
    type: "object",
    properties: {
      title: { type: "string" },
      body: { type: "string" },
      labels: { type: "array", items: { type: "string" } }
    }
  }
}
```

### データ処理

データを変換または分析するツール:

```typescript
{
  name: "analyze_csv",
  description: "CSVファイルを分析する",
  inputSchema: {
    type: "object",
    properties: {
      filepath: { type: "string" },
      operations: {
        type: "array",
        items: {
          enum: ["sum", "average", "count"]
        }
      }
    }
  }
}
```

## ベストプラクティス

ツールを実装する際:

1. 明確で説明的な名前と説明を提供する
2. パラメータの詳細な JSON スキーマ定義を使用する
3. モデルが使用方法を示すためにツールの説明に例を含める
4. 適切なエラーハンドリングと検証を実装する
5. 長期操作に進行状況レポートを使用する
6. ツール操作を焦点を絞ったアトミックに保つ
7. 期待される戻り値構造をドキュメント化する
8. 適切なタイムアウトを実装する
9. リソース集約的な操作にレート制限を検討する
10. デバッグと監視のためにツール使用をログ記録する

### ツール名の競合

MCP クライアントアプリケーションと MCP サーバープロキシは、独自のツールリストを構築する際にツール名の競合に遭遇する可能性があります。例えば、接続された 2 つの MCP サーバー`web1`と`web2`は両方とも`search_web`という名前のツールを公開する可能性があります。

アプリケーションは以下の戦略のいずれか（網羅的ではない）でツールを明確化できます:

- 一意のユーザー定義サーバー名とツール名を連結する、例: `web1___search_web`と`web2___search_web`。この戦略は、一意のサーバー名が設定ファイルでユーザーによってすでに提供されている場合に好ましい場合があります。
- ツール名のランダムなプレフィックスを生成する、例: `jrwxs___search_web`と`6cq52___search_web`。この戦略は、ユーザー定義の一意の名前が利用できないサーバープロキシで好ましい場合があります。
- サーバー URI をツール名のプレフィックスとして使用する、例: `web1.example.com:search_web`と`web2.example.com:search_web`。この戦略は、リモート MCP サーバーを操作する際に適している場合があります。

初期化フローからサーバーが提供する名前は一意であることが保証されておらず、一般的に明確化の目的には適していないことに注意してください。

## セキュリティの考慮事項

ツールを公開する際:

### 入力検証

- スキーマに対してすべてのパラメータを検証
- ファイルパスとシステムコマンドをサニタイズ
- URL と外部 ID を検証
- パラメータのサイズと範囲をチェック
- コマンドインジェクションを防止

### アクセス制御

- 必要に応じて認証を実装
- 適切な認可チェックを使用
- ツール使用を監査
- リクエストをレート制限
- 悪用を監視

### エラーハンドリング

- 内部エラーをクライアントに公開しない
- セキュリティ関連のエラーをログ記録
- タイムアウトを適切に処理
- エラー後にリソースをクリーンアップ
- 戻り値を検証

## ツールの発見と更新

MCP は動的なツール発見をサポートしています:

1. クライアントはいつでも利用可能なツールをリストできる
2. サーバーは`notifications/tools/list_changed`を使用してツールが変更されたことをクライアントに通知できる
3. ツールは実行時に追加または削除できる
4. ツール定義を更新できる（ただし、これは慎重に行うべき）

## エラーハンドリング

ツールエラーは、MCP プロトコルレベルのエラーとしてではなく、結果オブジェクト内で報告すべきです。これにより、LLM はエラーを見て、潜在的に処理できます。ツールがエラーに遭遇した場合:

1. 結果で`isError`を`true`に設定
2. `content`配列にエラーの詳細を含める

ツールの適切なエラーハンドリングの例は以下の通りです:

<Tabs>
  <Tab title="TypeScript">
    ```typescript
    try {
      // ツール操作
      const result = performOperation();
      return {
        content: [
          {
            type: "text",
            text: `操作成功: ${result}`
          }
        ]
      };
    } catch (error) {
      return {
        isError: true,
        content: [
          {
            type: "text",
            text: `エラー: ${error.message}`
          }
        ]
      };
    }
    ```
  </Tab>

  <Tab title="Python">
    ```python
    try:
        # ツール操作
        result = perform_operation()
        return types.CallToolResult(
            content=[
                types.TextContent(
                    type="text",
                    text=f"操作成功: {result}"
                )
            ]
        )
    except Exception as error:
        return types.CallToolResult(
            isError=True,
            content=[
                types.TextContent(
                    type="text",
                    text=f"エラー: {str(error)}"
                )
            ]
        )
    ```
  </Tab>
</Tabs>

このアプローチにより、LLM はエラーが発生したことを確認し、潜在的に是正措置を講じたり人間の介入を要求したりできます。

## ツールアノテーション

ツールアノテーションは、ツールの動作に関する追加のメタデータを提供し、クライアントがツールの提示と管理方法を理解するのに役立ちます。これらのアノテーションは、ツールの性質と影響を記述するヒントですが、セキュリティの決定には依存すべきではありません。

### ツールアノテーションの目的

ツールアノテーションはいくつかの重要な目的を果たします:

1. モデルのコンテキストに影響を与えずに UX 固有の情報を提供
2. クライアントがツールを適切に分類して提示するのを支援
3. ツールの潜在的な副作用に関する情報を伝達
4. ツール承認のための直感的なインターフェースの開発を支援

### 利用可能なツールアノテーション

MCP 仕様は、ツールに対して以下のアノテーションを定義しています:

| アノテーション    | タイプ  | デフォルト | 説明                                                                                                               |
| ----------------- | ------- | ---------- | ------------------------------------------------------------------------------------------------------------------ |
| `title`           | string  | -          | ツールの人間が読めるタイトル、UI 表示に便利                                                                        |
| `readOnlyHint`    | boolean | false      | true の場合、ツールは環境を変更しないことを示す                                                                    |
| `destructiveHint` | boolean | true       | true の場合、ツールは破壊的な更新を実行する可能性がある（`readOnlyHint`が false の場合のみ意味がある）             |
| `idempotentHint`  | boolean | false      | true の場合、同じ引数でツールを繰り返し呼び出しても追加の効果はない（`readOnlyHint`が false の場合のみ意味がある） |
| `openWorldHint`   | boolean | true       | true の場合、ツールは外部エンティティの「オープンワールド」と対話する可能性がある                                  |

### 使用例

異なるシナリオのアノテーション付きツールを定義する方法は以下の通りです:

```typescript
// 読み取り専用検索ツール
{
  name: "web_search",
  description: "情報をWeb検索する",
  inputSchema: {
    type: "object",
    properties: {
      query: { type: "string" }
    },
    required: ["query"]
  },
  annotations: {
    title: "Web検索",
    readOnlyHint: true,
    openWorldHint: true
  }
}

// 破壊的なファイル削除ツール
{
  name: "delete_file",
  description: "ファイルシステムからファイルを削除する",
  inputSchema: {
    type: "object",
    properties: {
      path: { type: "string" }
    },
    required: ["path"]
  },
  annotations: {
    title: "ファイル削除",
    readOnlyHint: false,
    destructiveHint: true,
    idempotentHint: true,
    openWorldHint: false
  }
}

// 非破壊的なデータベースレコード作成ツール
{
  name: "create_record",
  description: "データベースに新しいレコードを作成する",
  inputSchema: {
    type: "object",
    properties: {
      table: { type: "string" },
      data: { type: "object" }
    },
    required: ["table", "data"]
  },
  annotations: {
    title: "データベースレコード作成",
    readOnlyHint: false,
    destructiveHint: false,
    idempotentHint: false,
    openWorldHint: false
  }
}
```

### サーバー実装でのアノテーションの統合

<Tabs>
  <Tab title="TypeScript">
    ```typescript
    server.setRequestHandler(ListToolsRequestSchema, async () => {
      return {
        tools: [{
          name: "calculate_sum",
          description: "2つの数値を加算する",
          inputSchema: {
            type: "object",
            properties: {
              a: { type: "number" },
              b: { type: "number" }
            },
            required: ["a", "b"]
          },
          annotations: {
            title: "合計計算",
            readOnlyHint: true,
            openWorldHint: false
          }
        }]
      };
    });
    ```
  </Tab>

  <Tab title="Python">
    ```python
    from mcp.server.fastmcp import FastMCP

    mcp = FastMCP("example-server")

    @mcp.tool(
        annotations={
            "title": "合計計算",
            "readOnlyHint": True,
            "openWorldHint": False
        }
    )
    async def calculate_sum(a: float, b: float) -> str:
        """2つの数値を加算します。

        Args:
            a: 加算する最初の数値
            b: 加算する2番目の数値
        """
        result = a + b
        return str(result)
    ```

  </Tab>
</Tabs>

### ツールアノテーションのベストプラクティス

1. **副作用について正確に**: ツールが環境を変更するかどうか、およびそれらの変更が破壊的かどうかを明確に示す。

2. **説明的なタイトルを使用**: ツールの目的を明確に説明する人間にわかりやすいタイトルを提供する。

3. **冪等性を適切に示す**: 同じ引数での繰り返し呼び出しが本当に追加の効果を持たない場合にのみ、ツールを冪等としてマークする。

4. **適切なオープン/クローズドワールドヒントを設定**: ツールがクローズドシステム（データベースなど）と対話するか、オープンシステム（Web など）と対話するかを示す。

5. **アノテーションはヒントであることを覚えておく**: ToolAnnotations のすべてのプロパティはヒントであり、ツールの動作の忠実な説明を提供することは保証されていません。クライアントは、アノテーションのみに基づいてセキュリティクリティカルな決定を行うべきではありません。

## ツールのテスト

MCP ツールの包括的なテスト戦略は以下をカバーする必要があります:

- **機能テスト**: 有効な入力でツールが正しく実行され、無効な入力を適切に処理することを検証
- **統合テスト**: 実際の依存関係とモックされた依存関係の両方を使用して、外部システムとのツールの相互作用をテスト
- **セキュリティテスト**: 認証、認可、入力サニタイゼーション、レート制限を検証
- **パフォーマンステスト**: 負荷下の動作、タイムアウト処理、リソースクリーンアップをチェック
- **エラーハンドリング**: ツールが MCP プロトコルを通じてエラーを適切に報告し、リソースをクリーンアップすることを確認
